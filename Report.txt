The TLB serves as a cache for translating virtual addresses to physical addresses, improving memory access speed by storing frequently accessed address translations. The TLB is implemented as a dictionary with a fixed size in the provided code. Each entry consists of a page number and its corresponding frame number. To manage its size and ensure efficient replacement, a queue is utilized, employing either FIFO or LRU replacement policies based on the chosen configuration.
We designed the TLB as a Hashtable to keys of virtual page numbers that map to values of physical frame numbers. However, since hashtables don't have a built-in order, this became a problem when deciding to select a victim frame for the FIFO replacement order.
To solve this, we created a reference queue, which keeps track of accessed pages. When the TLB reaches its maximum capacity, the oldest entry, as determined by the reference queue, is evicted to make room for the new entry.

The Page Table is responsible for maintaining the mapping between virtual pages and physical frames. This mapping allows the CPU to access data stored in physical memory by translating virtual addresses to their corresponding physical addresses. Each entry in the Page Table represents a virtual page and contains the index of the corresponding physical frame where the page is stored. 
We designed this as an array where the indexes are the physical page numbers and the values are the frame numbers. To manage page replacement efficiently, the Page Table employs a reference queue or similar mechanism to track page access patterns to determine what the appropriate victim is to remove. The difference in the queue is that if an address references the page table then for FIFO it checks that page numbers are in the reference queue and if it is already in the queue then it does not get added to maintain the location where the page numbers were added. For LRU if this happens then that first location of the page number is removed and then the page number is added back to the end of the queue. For the OPT algorithm, we keep a hash table of the valid page numbers in the program at the time and a list of the translated page numbers of every address that will be accessed in our program. These valid page numbers are used when OPT needs to determine a victim frame. This victim frame is calculated by getting the distances from valid page numbers to the next occurrence of that page number in the remainder of the yet-to-be-translated addresses in the list of page numbers. We use the loaded bit in our page table by checking if the value at an index in the page table is None. This is updated accordingly when we invalidate a page number in the page table by setting it back to None when its original frame number gets allocated for a different page number. Lastly, in the TLB we check every TLB hit to see if the value at the index of the page number in the page table is None to ensure that the TLB entry is not invalid, and if it is None then we handle this as a page fault and allocate a new frame number for it through the specified page replacement algorithm.

Physical Memory is where actual page data resides—designed as an array with a length corresponding to the specified number of frames. Each element in the array represents a physical frame and is initialized to ‘None’, meaning the frame is empty. 
Our Physical Memory is responsible for managing the allocation of frames for storing page data. Page data is brought into physical memory from the secondary storage (BIN). When a new page needs to be loaded in memory after a page fault, our program identifies the next free frame to associate with the page number.  If there is a free frame available, we allocate it with the new page data. However, if there are no free frames, our program goes through the page replacement algorithm we explained in the previous section to determine the frame to replace with the new page’s data. 

Page faults can occur in our program when the page table does not have a valid entry associated with that page number. This can happen during the initial allocation of a frame for the page or if the frame becomes invalid due to the operation of the pager replacement algorithm. Additionally, page faults may occur if the frame is invalidated in either the page table or the TLB, leading to inconsistencies between the two data structures which are resolved by the page fault handler.

The MemSim program takes input parameters such as the reference sequence file, the number of frames, and the chosen page replacement algorithm. By reading virtual addresses from the input file, it simulates memory accesses and handles page faults. It tracks TLB hits and misses, updates the TLB and Page Table accordingly, and manages the contents of Physical Memory based on the replacement policy.
